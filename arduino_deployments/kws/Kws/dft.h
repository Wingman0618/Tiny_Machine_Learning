/*
Reference: https://www.youtube.com/watch?v=nl9TZanwbBk
           https://www.youtube.com/watch?v=Xw4voABxU5c
library for complex number computing: https://github.com/RobTillaart/Complex/tree/master
*/

#include <cmath>
#include <cstdlib>
#include <Complex.h>
#include <vector>
#include <limits.h>
#include <cfloat>

using namespace std;
// Referance: https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/
unsigned int bitReverse(unsigned int x, int log2n){
  int n=0;

  for(int i=0; i<log2n; i++){
    n <<= 1;
    n |= (x&1);
    x >>= 1;
  }

  return n;
}

void fft(vector<Complex> &a, vector<Complex> &A, int log2n){
  int n = 512;

  for(unsigned int i=0; i<n; i++){
    int rev = bitReverse(i, log2(n));
    A[i] = a[rev];
  }

  Complex j(0, 1);
  for(int s=1; s<=log2(n); s++){
    int m = 1 << s;
    int m2 = m >> 1;
    Complex w(1, 0);
    Complex e (M_E, 0);
    Complex wm = e.c_pow(j*(M_PI/m2));
    for(int i=0; i<m2; i++){
      for(int k=i; k<n; k+=m){
        Complex t = w*A[k+m2];
        Complex u = A[k];

        A[k] = u + t;

        A[k+m2] = u - t;
      }
      w *= wm;
    }
  }
}

double* rfft_abs(double* wave, int num_of_inputs){
  int n = num_of_inputs;
  int n_ffts = (n/2) + 1;

  double* result = (double*)malloc(n_ffts*sizeof(double));
  vector<Complex> wave_complex(n);
  vector<Complex> result_complex(n);
  
  for(int i=0; i<n; i++){
    Complex c_wave(*(wave+i), 0);
    wave_complex[i] = c_wave;
  }

  fft(wave_complex, result_complex, 9);
//  fft(wave_complex, result_complex, 4);
  for(int k=0; k<n_ffts; k++){
    double r = result_complex[k].real();
    double img = result_complex[k].imag();
    *(result+k) = sqrt(pow(r,2)+pow(img,2));
  }

  /*
  // Define the omega w
  // C++ complex implementation tutrial:
  Complex i(0., ((-2.*M_PI)/n));
  Complex e(M_E, 0);
  Complex w = e.c_pow(i);

  for(int k=0; k<n; k++){
    Complex coe = (0, 0);
    for(int j=0; j<n; j++){
      Complex inputs(wave[j], 0);
      coe += inputs*w.c_pow(j*k);
    }
    double r = coe.real();
    double img = coe.imag();
    *(result+k) = sqrt(pow(r,2)+pow(img,2));
  }
*/
  return result;
}

double* hamming_data(int8_t* wave, int num_of_inputs){
  vector<double> weight(num_of_inputs);
  double *result = (double*)malloc(num_of_inputs*sizeof(double));

  // Define min and max values for normalising the data
  double max;
  double min;

  for(int  i=0; i<num_of_inputs; i++){
    weight[i] = 0.54 - 0.46*cos((2.*M_PI*double(i))/(double(num_of_inputs)-1.));
    if(i==0){
      max = weight[i];
      min = weight[i];
    }
    if(i>0){
      if(weight[i]>=max){
        max = weight[i];
      }
      if(weight[i]<=min){
        min = weight[i];
      }
    }
  }
  // Normalise the data
  for(int i=0; i<num_of_inputs; i++){
    weight[i] = (weight[i]-min)/(max-min);
  }
  // weight the data
  for(int i=0; i<num_of_inputs; i++){
    *(result+i) = *(wave+i)*weight[i];
  }
  return result;
}

double* mel_spec(double* rfft_arr, int n_mels){
  double mel_weight;
  // Define the filterbin
  // The filterbin is generated by dft.h on https://github.com/Wingman0618/mel_spectrogram_library_for_Cpp
  int filterbin [] = {4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 17, 19, 20, 22, 24, 26, 28, 30, 32, 34, 37, 40, 42, 45, 48, 52, 55, 59, 62, 66, 71, 75, 80, 85, 90, 96, 101, 108, 114, 121, 128};

  // Define the output mel_result
  double* mel_result = (double*)malloc(n_mels*sizeof(double));
  
  // Compute the mel spectrogram
  for(int m=1; m<n_mels+1; m++){
    int f_min = filterbin[m-1];
    int f_mid = filterbin[m];
    int f_max = filterbin[m+1];

    mel_result[m-1] = 0.00;
    
    for(int k=f_min; k<f_mid; k++){
      mel_weight = (k - filterbin[m-1])/(filterbin[m] - filterbin[m-1]);
      mel_result[m-1] += mel_weight * rfft_arr[k];
    }

    for(int k=f_mid; k<f_max; k++){
      mel_weight = (filterbin[m+1] - k)/(filterbin[m+1] - filterbin[m]);
      mel_result[m-1] += mel_weight * rfft_arr[k];
    }
  }

  return mel_result;
}

double* amplitude_to_db(double* mel_spec, int input_size){
  double ref = INT_MIN;
  double min_double = DBL_MIN;

  double* mel_spec_db = (double*)malloc(input_size*sizeof(double));
  for(int i=0; i<input_size; i++){
    *(mel_spec_db+i) = mel_spec[i];
  }
  
  for(int i=0; i<input_size; i++){
    if(*(mel_spec_db+i) > ref){
      ref = *(mel_spec_db+i);
    }else{
      ref = ref;
    }
  }

  ref = pow(ref, 2);

  // Convert amplitude to db
  for(int i=0; i<input_size; i++){
    *(mel_spec_db+i) = pow(*(mel_spec_db+i), 2);
    *(mel_spec_db+i) = 10*log10(std::max(min_double, *(mel_spec_db+i)));
    *(mel_spec_db+i) -= 10*log10(std::max(min_double, ref));
  }

  double max_ = INT_MIN;
  for(int i=0; i<input_size; i++){
    if(*(mel_spec_db+i) > max_){
      max_ = *(mel_spec_db+i);
    }else{
      max_ = max_;
    }
  }

  //Define the top db as 80
  for(int i=0; i<input_size; i++){
    *(mel_spec_db+i) = std::max(*(mel_spec_db+i), (max_ - 80));
  }
  
  return mel_spec_db;  
}

int8_t* quantisation(double* input_arr, int input_size){
  int8_t* quant_result = (int8_t*)malloc(input_size*sizeof(int8_t));

  double max_ = INT_MIN;
  double min_ = INT_MAX;
  for(int i=0; i<input_size; i++){
    if(*(input_arr+i) > max_){
      max_ = *(input_arr+i);
    }else{
      max_ = max_;
    }
    if(*(input_arr+i) < min_){
      min_ = *(input_arr+i);
    }else{
      min_ = min_;
    }
  }

  double scale = 255/(max_ - min_);
  int zeropoint = -int(scale-min_+0.5)-128;
  
  for(int i=0; i<input_size; i++){
    *(quant_result+i) = int8_t(scale*input_arr[i]+zeropoint+0.5);
  }

  return quant_result;
}
